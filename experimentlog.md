由于是学习报告, 并不是实验报告。所以我将用比较零碎的语言，对自己在每个lab中**学到的东西**和**遇到的问题**进行描述。

## 前情提要

在开始做实验的时候，实验题以及实验代码并没有给出。所以我是照着指导书以及阅读实验全部代码逐步实现每个lab的。

# Lab0

## Q1

自定义panic(这些操作都没有在rust的教程中看到过.

```
error: `#[panic_handler]` function required, but not found
```

解决方法

```rust
use core::panic::PanicInfo
#[panic_handler]  //把下面定义的panic函数作为panic_handler, 负责在程序发生panic时调用
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

## Q2

错误相关语义项缺失 (用于标记某函数用来实现**堆栈展开**处理功能的语义项

```
error: language item required, but not found: `eh_personality`
```

将 dev 配置和 release 配置的 panic 的处理策略设为直接终止，也就是直接调用我们的 `panic_handler` 而不是先进行堆栈展开等处理再调用。

解决方法: 在cargo.toml中设置panic的处理策略为直接终止

```rust
# panic 时直接终止，因为我们没有实现堆栈展开的功能
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```



## Q3

RISC-V 中，内存的物理地址是从 0x80000000 开始的, 为了保证用户进程不能直接操作内核,保证内核的安全.

所以需要调整内存布局.



## Q4

### 重写程序入口点`_start`

CPU加电后运行在`M mode`(Machine mode), 我们要实现的OS内核运行在`S mode` .

OpenSBI固件做的事是把CPU从`M mode`切换成`S mode` 





## Q5

`console_putchar`的实现

[内联汇编模板]([https://kaisery.gitbooks.io/rust-book-chinese/content/content/Inline%20Assembly%20%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96.html](https://kaisery.gitbooks.io/rust-book-chinese/content/content/Inline Assembly 内联汇编.html))

我们通过 ecall 发起系统调用。OpenSBI 会检查发起的系统调用的编号，如果编号在 0-8 之间，则进行处理，否则交由我们自己的中断处理程序处理.

执行 `ecall` 前需要指定系统调用的编号，传递参数。一般而言，`a7` 为系统调用编号，`a0`、`a1` 和 `a2` 为参数：

```rust
//! 调用 Machine 层的操作
// 目前还不会用到全部的 SBI 调用，暂时允许未使用的变量或函数
#![allow(unused)]

/// SBI 调用
#[inline(always)]
fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    let ret;
    unsafe {
        llvm_asm!("ecall"
            : "={x10}" (ret) //输出部分，我们将结果保存到变量ret中，限制条件 {x10} 告诉编译器使用寄存器 x10（即 a0 寄存器），前面的 = 表明汇编代码会修改该寄存器并作为最后的返回值。
            
            : "{x10}" (arg0), "{x11}" (arg1), "{x12}" (arg2), "{x17}" (which)
            //输入部分，我们分别通过寄存器 x10、x11、x12 和 x17（这四个寄存器又名 a0、a1、a2 和 a7） 传入参数 arg0、arg1、arg2 和 which ，其中前三个参数分别代表接口可能所需的三个输入参数，最后一个 which 用来区分我们调用的是哪个接口（SBI Extension ID）。这里之所以提供三个输入参数是为了将所有接口囊括进去，对于某些接口有的输入参数是冗余的，比如 sbi_console_putchar 由于只需一个输入参数，它就只关心寄存器 a0 的值。
            
            : "memory"      // 如果汇编可能改变内存，则需要加入 memory 选项
            : "volatile");  // 为了防止编译器做激进的优化（如调换指令顺序等破坏 SBI 调用行为的优化）
    }
    ret
}
```

由于`llvm_asm`不稳定, 在编译的时候会报错。因此需要在`main.rs`中添加`#![feature(llvm_asm)]`.(不知道为什么在`sbi.rs`中添加没有效果)





## Q6

[简单的正则表达式介绍](https://www.runoob.com/regexp/regexp-syntax.html)

| 特别字符 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 \$ 也匹配 '\n' 或 '\r'。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 |
| *        | 匹配前面的子表达式零次或多次。                               |
| +        | 匹配前面的子表达式一次或多次。                               |
| .        | 匹配除换行符 \n 之外的任何单字符。                           |
| [        | 标记一个中括号表达式的开始。                                 |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。       |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。 |
| {        | 标记限定符表达式的开始。                                     |
| \|       | 指明两项之间的一个选择。                                     |
|          |                                                              |





# Lab1

实验一的第一部分探索了中断部分的内容：

- 什么是中断
- 与中断相关的一些寄存器
- 与中断相关的一些指令
- 读写CSR的指令

接下来就到了正式的实验环节。指导书上说习题只需要基于给出的版本增量实现，我觉得这是完全不够的。实验指导书中的代码由于只有一部分，所以仅靠指导书中的一些代码并不能完全理解指导书中所说的一些含义。当然这也是无法避免的事，为了在篇幅和易懂性中做出合适的选择，必须放弃一定的效果。

并且在看指导书的时候比较难以掌握整个实验的框架是如何的，代码文件是如何分布的，这就需要自己去源代码中进行琢磨，最好的方式就是手动实现一部分。

我采取的方式就是如此，以实验指导书中的代码为基础，通过这些代码去构建一个完整的实验。当然，实验指导书也说了，如果想仅仅通过指导书来实现一个rcore是比较困难的，所以我是在复制指导书的代码后（一开始还是手敲的，但是后来嫌慢了就复制了），make run一下。通常都会有很多的报错，一般来说报错都是缺少一些调用某个模块，没有把某个模块包含进去之类的问题。这也能更好地理解cargo的包管理系统的使用。

下面是当时做实验的时候的一些问题。

## Q1

```asm
# Context, scause 和 stval 作为参数传入
    mv a0, sp
    csrr a1, scause
    csrr a2, stval
    jal  handle_interrupt

    .globl __restore
# 离开中断
# 从 Context 中恢复所有寄存器，并跳转至 Context 中 sepc 的位置
__restore:
    # 恢复 CSR
    LOAD    s1, 32
    LOAD    s2, 33
    # 思考：为什么不恢复 scause 和 stval？如果不恢复，为什么之前要保存
    csrw    sstatus, s1
    csrw    sepc, s2
```

关于这个问题, scause和stval传给a1和a2只是为了传递参数, 并没有保存到栈中。

再者，中断处理完成之后也没有必要恢复这个中断产生的原因是什么了。





## Q2

因为学习过汇编\计组\电子工艺实习, 所以对中断这块相对于其他几个实验是更加了解的。

代码配上注释基本能够知道为什么要这么做。但是如果要自己实现一下的话，可能还有一定的差距。



这个实验的整个流程是进入到rustmain函数之后， 初始化中断，开启中断， 然后进入中断，进入interrupt.asm文件,保存现场, 在进入handle_interrupt,  判断出中断类型是断点， 进入断点处理函数， 处理完之后恢复现场, 最后程序跳回sepc 的位置.

## Q3

这里是对于实验题的一些回答。

1. sp减去了Context所需的空间(34*8), 因为要把Context中的寄存器保存到栈中.

   再把sp写入到第二个位置。 在中断过程中可能会使用到栈，所以sp会变化， 但是在中断结束之后， sp就恢复到了中断之前的值



2. 去掉panic之后会顺序执行下面的指令， 但是因为后面没有指令了， 所以会执行内存中的任意指令。



3. 在match中添加一个处理case



实验一题目完成， 保存在wsl中的lab1位置。





# Lab2、3

这个实验和实验三着实让人有些头疼。关于内存处理这块涉及了大量的层次化结构，如果没有厘清一些变量的概念和整体的框架，很容易在前面看了这个变量的定义，实现的方法；在后面就忘了，然后就得一步一步向前看某个结构体的定义。

由于这两个实验都是一个整体，因此把他们合在一起。

实验二实现了动态内存分配功能，并且定义了物理页的概念，为实验三奠定了基础。

虽然实验二的指导书内容看起来只有一点，但是由于后来出了实验题之后，自己选择实现了一下伙伴算法，才让我真正地对伙伴算法有了更加深刻的理解。虽然伙伴算法在理论上，解释起来也比较容易懂，但是我在阅读一些代码，包括清华陈嘉杰学长实现的伙伴系统算法的源码的时候，遭遇了非常大的困难。单纯地看代码不能很好地理解一些操作的含义，因为代码中也没有十分友好的注释，再加上自己对于rust以及伙伴系统也没有十分深刻的理解。直到我选择将代码拷贝下来，然后自己运行一遍，将一些变量的值打印出来之后，才能验证自己的想法。因此我在代码中加了较多的注释，以及打印语句。





# Lab4



